import AbseilHelpers;
import AbseilConfigureCopts;

int main() {
  auto stacktrace = absl::cc_library(
      "stacktrace", {.hdrs = {"stacktrace.h"},
                     .srcs = {"stacktrace.cc"},
                     .copts = absl::default_copts,
                     .deps = {debugging_internal, base, core_headers},
                     .public = true});

  auto symbolize = absl::cc_library(
      "symbolize",
      {.hdrs = {"symbolize.h", "internal/symbolize.h"},
       .srcs = {"symbolize.cc", "symbolize_elf.inc",
                "symbolize_unimplemented.inc", "symbolize_win32.inc"},
       .copts = absl::default_copts,
       .linkopts = absl::default_linkopts,
       .deps = {debugging_internal, base, core_headers, demangle_internal,
                malloc_internal},
       .public = true});

  absl::cc_test("symbolize_test", {.srcs = {"symbolize_test.cc"},
                                   .copts = absl::test_copts,
                                   .deps = {stack_consumption, symbolize, base,
                                            core_headers, memory, gtest_main}});

  auto examine_stack = absl::cc_library(
      "examine_stack", {.hdrs = {"internal/examine_stack.h"},
                        .srcs = {"internal/examine_stack.cc"},
                        .copts = absl::default_copts,
                        .deps = {stacktrace, symbolize, base, core_headers}});

  auto failure_signal_handler = absl::cc_library(
      "failure_signal_handler",
      {.hdrs = {"failure_signal_handler.h"},
       .srcs = {"failure_signal_handler.cc"},
       .copts = absl::default_copts,
       .deps = {examine_stack, stacktrace, base, config, core_headers},
       .public = true});

  absl::cc_test("failure_signal_handler_test",
                {.srcs = {"failure_signal_handler_test.cc"},
                 .copts = absl::test_copts,
                 .deps = {failure_signal_handler, stacktrace, symbolize, base,
                          strings, Threads::Threads, gmock}});

  auto debugging_internal = absl::cc_library(
      "debugging_internal",
      {.hdrs = {"internal/address_is_readable.h", "internal/elf_mem_image.h",
                "internal/stacktrace_aarch64-inl.inc",
                "internal/stacktrace_arm-inl.inc",
                "internal/stacktrace_config.h",
                "internal/stacktrace_generic-inl.inc",
                "internal/stacktrace_powerpc-inl.inc",
                "internal/stacktrace_unimplemented-inl.inc",
                "internal/stacktrace_win32-inl.inc",
                "internal/stacktrace_x86-inl.inc", "internal/vdso_support.h"},
       .srcs = {"internal/address_is_readable.cc", "internal/elf_mem_image.cc",
                "internal/vdso_support.cc"},
       .copts = absl::default_copts,
       .deps = {base, core_headers, dynamic_annotations}});

  auto demangle_internal =
      absl::cc_library("demangle_internal", {.hdrs = {"internal/demangle.h"},
                                             .srcs = {"internal/demangle.cc"},
                                             .copts = absl::default_copts,
                                             .deps = {base, core_headers}});

  absl::cc_test("demangle_test",
                {.srcs = {"internal/demangle_test.cc"},
                 .copts = absl::test_copts,
                 .deps = {demangle_internal, stack_consumption, base,
                          core_headers, memory, gmock_main}});

  auto leak_check =
      absl::cc_library("leak_check", {.hdrs = {"leak_check.h"},
                                      .srcs = {"leak_check.cc"},
                                      .copts = absl::default_copts,
                                      .deps = {core_headers},
                                      .public = true});

  auto leak_check_disable =
      absl::cc_library("leak_check_disable", {.srcs = {"leak_check_disable.cc"},
                                              .copts = absl::default_copts,
                                              .public = true});

  {
    auto copts = absl::default_copts;
    if (absl::have_lsan) {
      copts += "-DLEAK_SANITIZER";
    }
    auto leak_check_api_enabled_for_testing = absl::cc_library(
        "leak_check_api_enabled_for_testing", {.hdrs = {"leak_check.h"},
                                               .srcs = {"leak_check.cc"},
                                               .copts = copts,
                                               .testonly = true});
  }

  auto leak_check_api_disabled_for_testing =
      absl::cc_library("leak_check_api_disabled_for_testing",
                       {.hdrs = {"leak_check.h"},
                        .srcs = {"leak_check.cc"},
                        .copts = absl::default_copts + "-ULEAK_SANITIZER",
                        .testonly = true});

  {
    auto copts = absl::default_copts;
    if (absl::have_lsan) {
      copts += "-DABSL_EXPECT_LEAK_SANITIZER";
    }
    absl::cc_test("leak_check_test",
                  {.srcs = {"leak_check_test.cc"},
                   .copts = copts,
                   .linkopts = absl::lsan_linkopts.deps = {
                       leak_check_api_enabled_for_testing, base, gmock_main}});
  }
  absl::cc_test(
      "leak_check_no_lsan_test",
      {.srcs = {"leak_check_test.cc"},
       .copts = absl::test_copts + "-UABSL_EXPECT_LEAK_SANITIZER",
       .deps = {leak_check_api_enabled_for_testing, base, gmock_main}});

  absl::cc_test("disabled_leak_check_test",
                {.srcs = {"leak_check_fail_test.cc"},
                 .copts = absl::test_copts,
                 .linkopts = absl::lsan_linkopts,
                 .deps = {leak_check_api_enabled_for_testing,
                          leak_check_disable, base, gmock_main}});

  auto stack_consumption = absl::cc_library(
      "stack_consumption", {.hdrs = {"internal/stack_consumption.h"},
                            .srcs = {"internal/stack_consumption.cc"},
                            .copts = absl::default_copts,
                            .deps = {base, core_headers}.testonly = true});

  absl::cc_test("stack_consumption_test",
                {.srcs = {"internal/stack_consumption_test.cc"},
                 .copts = absl::test_copts,
                 .deps = {stack_consumption, base, core_headers, gmock_main}});

  auto debugging = absl::cc_library(
      "debugging", {.copts = absl::default_copts,
                    .deps = {stacktrace, leak_check}.public = true});
}
